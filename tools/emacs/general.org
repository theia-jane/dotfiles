#+TITLE: General
#+PROPERTY: header-args :tangle-relative 'dir

* Overview
** Layers of packages
*** System packages
AKA 'site-lisp' directory. Installed under ~/usr/share/emacs/site-lisp~ on a unix system.
*** User local packages
For me located at ~~/.local/emacs/site-lisp~, which is enabled via ~EMACSLOADPATH~
*** Repo packages
For me located at ~$dot/tools/emacs/packages~, which is enabled via ~EMACSLOADPATH~
*** User local "global" packages
These packages are installed by =(global-packages/install-packages)= in ~~/.local/emacs/site-lisp/global-packages.el~ via =elpm=.

* Building emacs
** Init Repository
Get the repository and get it ready to build
#+begin_src bash :dir ~/.local/src :mkdirp yes
[ ! -d "emacs" ] \
    && git clone https://git.savannah.gnu.org/git/emacs.git emacs \
    && cd emacs \
    && ./autogen.sh
#+end_src
** Configuring build
To see what options there are to configure emacs during the build run =./configure --help=. For my linux build I use:
#+begin_src bash :dir ~/.local/src/emacs
nice -n 10 ./configure \
    --prefix=/usr \
    --sysconfdir=/etc \
    --libexecdir=/usr/lib \
    --localstatedir=/var \
    --mandir=/usr/share/man \
    --with-gameuser=:games \
    --with-x \
    --with-sound=alsa \
    --with-x-toolkit=gtk3 \
    --with-xft \
    --without-gconf \
    --without-gsettings \
    --without-xaw3d \
    --with-xwidgets \
    --with-file-notification=inotify \
    --with-json \
    --with-nativecomp \
    --with-modules \
    --with-pdumper \
    --without-compress-install \
    --enable-link-time-optimization \
    'CFLAGS=-march=x86-64 -mtune=generic -O2 -pipe -fno-plt -flto' \
    CPPFLAGS=-D_FORTIFY_SOURCE=2 \
    LDFLAGS=-Wl,-O1,--sort-common,--as-needed,-z,relro,-z,now
#+end_src
** Build it!
:PROPERTIES:
:header-args+: :dir ~/.local/src/emacs
:END:
#+begin_src bash
nice -n 10 make
#+END_SRC

Make sure it works the way you want it to
#+begin_src bash
./src/emacs
#+end_src

Then install it (might need =sudo=)
#+begin_src bash
make install
#+end_src
** TODO Add pdump with my config, local libraries & 'required' libraries
I think you can create a dump file that emacs can load up /quickly/ into memory. Stuff in here should be stuff that doesn't change much.

* Scripts
:PROPERTIES:
:header-args: :dir ${HOME}/bin
:header-args:bash: :shebang #!/bin/bash
:header-args:elisp: :shebang #!/usr/bin/env -S emacs -Q --script # -*- mode: emacs-lisp; lexical-binding: t; -*-
:END:

** Daemon
#+BEGIN_SRC bash :tangle emacsd.start
echo "Starting emacs daemon..." >> /tmp/emacsd.log
emacs --daemon >> /tmp/emacsd.log 2>&1 &
#+END_SRC

#+BEGIN_SRC bash :tangle emacsd.stop
echo "Stopping emacs daemon..." >> /tmp/emacsd.log

(emacsdclient -e "(kill-emacs)"; \
  pkill ^emacs$) >> /tmp/emacsd.log 2>&1
#+END_SRC

#+BEGIN_SRC bash :tangle emacsd.restart
emacsd.stop
emacsd.start
#+END_SRC

#+BEGIN_SRC bash :tangle emacsdclient
# Wait a max of 100s
sleep_length="0.1s"
max_tries=1000

# If there is no daemon.. let's try to get it started and then launch the client
if [ -z "$(pgrep -f 'emacs --daemon')" ]; then
  emacsd.start
fi

succeeded_in_launching=false
for try_n in $(seq $max_tries); do
  if [ ! -z "$(pgrep -f 'emacs --daemon')" ]; then
    (emacsclient "$@" > /dev/null) \
        && succeeded_in_launching=true \
        && break 
  fi

  sleep $sleep_length
  if [ "$try_n" = "15" -o "$try_n" = "150" -o "$try_n" = "500" ]; then
      notify-send -t 1000 "emacs daemon is starting..." 
  fi 
done

if ! $succeeded_in_launching; then
  echo 'Error: emacs daemon had an issue starting up.' 1>&2
fi
#+END_SRC

#+BEGIN_SRC bash :tangle emacsdclient-bg
d emacsdclient "$@"
#+END_SRC
** Launch
#+BEGIN_SRC bash :tangle i3.dd.emacs
# Toggle floating emacs frame in i3, or start if non-existing.

name='Dropdown: Emacs'
if [ ! -z "$@" ]; then
  name="${name} ($(echo "$@" | md5sum | cut -f1 -d' '))"
fi

if xwininfo -tree -root | grep "\"${name}\": (";
then
	echo "Window detected."
	i3-msg "[title=\"^${name}\"] scratchpad show"
else
	echo "Window not detected... spawning."
  emacsdclient -c -F '((width . 120) (height . 40) (name . "'"$name"'"))' "$@"
fi
#+END_SRC

#+BEGIN_SRC bash :tangle dired
DIR="${1:-$(pwd)}"
emacsdclient-bg -ce \
"
(progn
 (dired \"$DIR\"))
"
#+END_SRC

#+BEGIN_SRC bash :tangle magit
el "(magit)"
#+END_SRC

#+BEGIN_SRC bash :tangle e.f
el "(counsel-find-file)"
#+END_SRC

#+BEGIN_SRC bash :tangle e.emacs
files_to_edit="$@"
if [ -z "$files_to_edit" ]; then
  files_to_edit="."
fi

dir=""
lisp=""
for file_name in $files_to_edit; do
  # Resolve file name (expand env vars and deal with tilda)
  file_name="$(expand-file-name "$file_name")"

  if [ -d "$file_name" ]; then
    dir="$file_name"
    lisp="
(if (projectile-project-p)
  (+ivy/projectile-find-file)
  (counsel-find-file))) "
    break;
  fi

  lisp+='(find-file "'$file_name'")'
done

lisp="(progn ${lisp})"

if [ ! -z "$dir" ]; then
  cd "$dir"
fi
emacsdclient-bg -c -e "$lisp"
#+END_SRC

#+begin_src bash :tangle emacs-from-dir
# To work this requires a version of chemacs that allows for loading the config from the CLI
DIR="$1"
shift
[ -d "$DIR" ] \
    && emacs --with-profile '((user-emacs-directory . "'$DIR'"))' $@
#+end_src

#+BEGIN_SRC bash :tangle try-emacs-config :comments no
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
(require 'url)
(defconst repos-dir "/tmp/emacs-try")

(defun ensure-repos-dir ()
  "Make sure the repos dir exists"
  (or (file-exists-p repos-dir)
      (mkdir repos-dir t)))

(defun get-repo-link ()
  (let ((link (with-temp-buffer
                (shell-command "v" (current-buffer))
                (url-get-url-at-point (point-min)))))
    (or link "")))

(defun get-repo-name (repo-link)
  (save-match-data
    (and (string-match "\\([^/]+\\)*/\\([^/]+\\)$" repo-link)
         (format "%s__%s" (match-string 1 repo-link) (match-string 2 repo-link)))))

(when-let ((repo-link (get-repo-link)))
        (ensure-repos-dir)
        (let ((default-directory repos-dir)
              (repo-name (get-repo-name repo-link)))
          (unless (file-exists-p repo-name)
                (shell-command-to-string (format "git clone %s %s" repo-link repo-name)))
          (shell-command-to-string (format "d emacs-from-dir %s" repo-name))))
#+end_src

** Eval
#+BEGIN_SRC bash :tangle el
EXTRA_PARAMS=""
NO_FRAME="false"
CALL_INTERACTIVELY="false"
while true; do
  case "$1" in
    -nf|--no-frame)
      NO_FRAME="true"
      shift 1
      ;;
    -mx)
      CALL_INTERACTIVELY="true"
      shift 1
      ;;
      *)
      break
      ;;
  esac
done

if [ "${CALL_INTERACTIVELY}" = "true" ]; then
  ELISP="(funcall-interactively #'${1})"
else
  ELISP="$@"
fi


if [ "${NO_FRAME}" = "false" ]; then
  EXTRA_PARAMS+="-c "
fi

emacsdclient-bg $EXTRA_PARAMS -e "${ELISP}"
#+END_SRC

#+BEGIN_SRC bash :tangle mx
FORWARD_ARGS=""
while true; do
  case "$1" in
    -nf|--no-frame)
      FORWARD_ARGS+="$1 "
      shift 1
      ;;
      *)
      break
      ;;
  esac
done

el $FORWARD_ARGS -mx "$1"
#+END_SRC
* Packages
:PROPERTIES:
:header-args: :dir ${HOME}/.local/emacs/site-lisp
:END:
** Global packages
Simply requiring this will make all of my globally installed packages available to me in any instance of emacs -- useful.
#+begin_src elisp :tangle global-packages.el
(require 'elpm)
(require 'seq)
(require 'info)

(defvar global-packages-dir
  (expand-file-name "~/.local/emacs/site-lisp/"))

(defvar global-packages-cache-file
  (concat global-packages-dir "global-packages-cache.el"))

(defvar global-packages-required-packages
  '(evil evil-collection which-key general
     helpful try magit
     eros yasnippet
     corfu 
     org org-contrib
     orderless marginalia 
     consult embark embark-consult
     use-package f s async dash
     auto-minor-mode
    ))

(defvar global-packages-load-path '())
(defvar global-packages-Info-directory-list '())

(defun global-packages/install-packages ()
  (let ((old-load-path load-path)
        (old-Info-directory-list Info-directory-list))
    (elpm-use-packages global-packages-required-packages global-packages-dir t)
    (global-packages/add-load-paths (seq-difference load-path old-load-path))
    (global-packages/add-Info-directories (seq-difference Info-directory-list old-Info-directory-list))
    (global-packages/save-cache-file)))

(defun global-packages/save-cache-file ()
  (with-temp-buffer
    (insert (pp-to-string (list :load-path global-packages-load-path
                                :info-directory-list global-packages-Info-directory-list)))
    (write-region (point-min) (point-max) global-packages-cache-file)))

(defun global-packages/load-cache-file ()
  (let* ((file-name global-packages-cache-file)
         (file-contents (when (file-exists-p file-name)
                          (with-temp-buffer
                            (insert-file-contents file-name)
                            (buffer-string))))
         (cache (and file-contents
                     (not (equal file-contents ""))
                     (car (read-from-string file-contents)))))
    (when (listp cache)
      (global-packages/add-Info-directories (plist-get cache :info-directory-list))
      (global-packages/add-load-paths (plist-get cache :load-path)))))

(defun global-packages/add-load-paths (load-path-additions)
  (dolist (path load-path-additions)
    (when (stringp path)
      (add-to-list 'global-packages-load-path path)
      (add-to-list 'load-path path))))

(defun global-packages/add-Info-directories (info-directory-additions)
  (dolist (path info-directory-additions)
    (when (stringp path)
      (add-to-list 'global-packages-Info-directory-list path)
      (add-to-list 'Info-directory-list path))))

(defun global-packages/init ()
  (if (file-exists-p global-packages-cache-file)
      (global-packages/load-cache-file)
    (global-packages/install-packages))
  (require 'use-package)
  (require 'auto-minor-mode))

;; Better to ignore any errors since this loaded in every emacs session
(global-packages/init)

(provide 'global-packages)
#+end_src
*** TODO make =global-packages/init= an autoloaded fn
** Global settings
:PROPERTIES:
:header-args:elisp: :tangle global-settings.el
:END:
#+begin_src elisp
(provide 'global-settings)
#+end_src
*** Cache directories
Cache directories are the home of those things which can be
deleted at anytime without an noticable difference to behavior
-- with the exception of performance.
#+begin_src elisp
(defvar user-cache-directory (expand-file-name "~/.cache/"))
(defvar emacs-cache-directory (concat user-cache-directory "emacs/"))
#+END_SRC

*** Local directories
Local directories are the home of things that aren't quite
cache, but also aren't suitable for version control. If
these are deleted then some behavior / value / is lost, but
no core functionality should be broken or majorly changed.
#+begin_src elisp
(defvar user-local-directory (expand-file-name "~/.local/"))
(defvar emacs-local-directory (concat user-local-directory "emacs/"))
#+end_src

*** Config directories
Config directories are the home of things that should be managed
by things that are under version control. Changes to anything
in these directories is expected to break things or at least
cause a change in behavior. 
#+begin_src elisp
(defvar user-config-directory (expand-file-name "~/.config/"))
(defvar emacs-config-directory (concat user-config-directory "emacs/"))
#+end_src
*** Enable 'disabled' features
#+begin_src elisp
(put 'erase-buffer 'disabled nil)
(put 'narrow-to-region 'disabled nil)
#+end_src
*** Yes or no 
#+begin_src elisp
(fset #'yes-or-no-p #'y-or-n-p)
#+end_src

#+RESULTS:
: y-or-n-p

** Experiments
:PROPERTIES:
:header-args:elisp: :tangle experiment.el
:END:
It's useful to perform experiments to learn new things. To be somewhat effective
it's best to isolate variables and have a stable environment to do so. Hopefully
this will provide a basic starting point for my emacs experiments.

#+BEGIN_SRC elisp
(provide 'experiment)
(require 'global-packages)
(setq experiment-directory (or (and (boundp 'experiment-directory)
                                    experiment-directory)
                               (make-temp-file "/tmp/emacs-experiment" t))
      user-emacs-directory experiment-directory
      elpm-directory experiment-directory)

;; Minimal setup
(require! config-evil
          evil

          config-selection-completion
          ivy
          counsel
          ivy-rich

          config-introspection
          which-key
          helpful)

;; Init packages
(elpm-use-packages '())
#+END_SRC

** Personal lib
:PROPERTIES:
:header-args:elisp: :tangle personal-lib.el
:END:
#+BEGIN_SRC elisp
(provide 'personal-lib)
(require 'commands-lib)
(require 'use-package)
#+END_SRC

*** Loading
#+BEGIN_SRC elisp
(defmacro after! (package-or-list &rest body)
  "Do BODY after PACKAGE-OR-LIST have loaded.

Just leverages `use-package'."
  `(use-package emacs
     :defer t
     :after ,(enlist package-or-list) 
     :config (progn ,@body)))

(defalias
  'config!
  'after!
  "Just configure a package(s).. Nothing else!

Alias of `after!' that is a little more descriptive at times.")
#+END_SRC

#+BEGIN_SRC elisp
(defmacro before! (package &rest body)
  "Do BODY before PACKAGE has been loaded.

Just leverages `use-package'."
  `(use-package ,package
     :defer t
     :init (progn ,@body)))

(defalias
  'init!
  'before!
  "Initialize a package (settings to be set before it's loaded)")
#+END_SRC

#+BEGIN_SRC elisp
(defmacro defer-until! (condition &rest body)
  "Run BODY when CONDITION is true (checks on `after-load-functions'). Meant to
serve as a predicated alternative to `after!'.

Taken from doom-emacs."
  (declare (indent defun) (debug t))
  `(if ,condition
       (progn ,@body)
     ,(let ((fn (intern (format "--delay-form-%s-h" (sxhash (cons condition body))))))
        `(progn
           (fset ',fn (lambda (&rest args)
                        (when ,(or condition t)
                          (remove-hook 'after-load-functions #',fn)
                          (unintern ',fn nil)
                          (ignore args)
                          ,@body)))
           (put ',fn 'permanent-local-hook t)
           (add-hook 'after-load-functions #',fn)))))
#+END_SRC

#+BEGIN_SRC elisp
(defmacro require! (&rest requires)
  `(dolist (rargs ',requires)
     (apply #'require `,(enlist rargs))))
#+END_SRC
*** General helpers
#+BEGIN_SRC elisp
(defun unquote (exp)
  "Return EXP unquoted."
  (declare (pure t) (side-effect-free t))
  (while (memq (car-safe exp) '(quote function))
    (setq exp (cadr exp)))
  exp)

(defun enlist (exp)
  "Return EXP wrapped in a list, or as-is if already a list.

Note: excludes keymaps as 'lists'"
  (declare (pure t) (side-effect-free t))
  (if (and (listp exp)
           (not (keymapp exp)))
      exp
    (list exp)))


(defun keyword-intern (str)
  "Converts STR (a string) into a keyword (`keywordp')."
  (declare (pure t) (side-effect-free t))
  (cl-check-type str string)
  (intern (concat ":" str)))

(defun keyword-name (keyword)
  "Returns the string name of KEYWORD (`keywordp') minus the leading colon."
  (declare (pure t) (side-effect-free t))
  (cl-check-type keyword keyword)
  (substring (symbol-name keyword) 1))

(defun resolve-hook-forms (hooks)
  "Converts a list of modes into a list of hook symbols.

If a mode is quoted, it is left as is. If the entire HOOKS list is quoted, the
list is returned as-is."
  (declare (pure t) (side-effect-free t))
  (let ((hook-list (enlist (unquote hooks))))
    (if (eq (car-safe hooks) 'quote)
        hook-list
      (cl-loop for hook in hook-list
               if (eq (car-safe hook) 'quote)
               collect (cadr hook)
               else collect (intern (format "%s-hook" (symbol-name hook)))))))

(defun setq-hook-fns (hooks rest &optional singles)
  (unless (or singles (= 0 (% (length rest) 2)))
    (signal 'wrong-number-of-arguments (list #'evenp (length rest))))
  (cl-loop with vars = (let ((args rest)
                             vars)
                         (while args
                           (push (if singles
                                     (list (pop args))
                                   (cons (pop args) (pop args)))
                                 vars))
                         (nreverse vars))
           for hook in (resolve-hook-forms hooks)
           for mode = (string-remove-suffix "-hook" (symbol-name hook))
           append
           (cl-loop for (var . val) in vars
                    collect
                    (list var val hook
                          (intern (format "--setq-%s-for-%s-h"
                                          var mode))))))
#+END_SRC
*** Hooks
#+BEGIN_SRC elisp
(defmacro add-hook-trigger! (hook-var &rest targets)
  "TODO"
  `(let ((fn (intern (format "%s-h" ,hook-var))))
     (fset fn (lambda (&rest _) (run-hooks ,hook-var) (set ,hook-var nil)))
     (put ,hook-var 'permanent-local t)
     (dolist (on (list ,@targets))
       (if (functionp on)
           (advice-add on :before fn)
         (add-hook on fn)))))

(defmacro add-hook! (hooks &rest rest)
  "A convenience macro for adding N functions to M hooks.

This macro accepts, in order:

  1. The mode(s) or hook(s) to add to. This is either an unquoted mode, an
     unquoted list of modes, a quoted hook variable or a quoted list of hook
     variables.
  2. Optional properties :local and/or :append, which will make the hook
     buffer-local or append to the list of hooks (respectively),
  3. The function(s) to be added: this can be one function, a quoted list
     thereof, a list of `defun's, or body forms (implicitly wrapped in a
     lambda).

\(fn HOOKS [:append :local] FUNCTIONS)"
  (declare (indent (lambda (indent-point state)
                     (goto-char indent-point)
                     (when (looking-at-p "\\s-*(")
                       (lisp-indent-defform state indent-point))))
           (debug t))
  (let* ((hook-forms (resolve-hook-forms hooks))
         (func-forms ())
         (defn-forms ())
         append-p
         local-p
         remove-p
         forms)
    (while (keywordp (car rest))
      (pcase (pop rest)
        (:append (setq append-p t))
        (:local  (setq local-p t))
        (:remove (setq remove-p t))))
    (let ((first (car-safe (car rest))))
      (cond ((null first)
             (setq func-forms rest))

            ((eq first 'defun)
             (setq func-forms (mapcar #'cadr rest)
                   defn-forms rest))

            ((memq first '(quote function))
             (setq func-forms
                   (if (cdr rest)
                       (mapcar #'unquote rest)
                     (enlist (unquote (car rest))))))

            ((setq func-forms (list `(lambda (&rest _) ,@rest)))))
      (dolist (hook hook-forms)
        (dolist (func func-forms)
          (push (if remove-p
                    `(remove-hook ',hook #',func ,local-p)
                  `(add-hook ',hook #',func ,append-p ,local-p))
                forms)))
      (macroexp-progn
       (append defn-forms
               (if append-p
                   (nreverse forms)
                 forms))))))

(defmacro remove-hook! (hooks &rest rest)
  "A convenience macro for removing N functions from M hooks.

Takes the same arguments as `add-hook!'.

If N and M = 1, there's no benefit to using this macro over `remove-hook'.

\(fn HOOKS [:append :local] FUNCTIONS)"
  (declare (indent defun) (debug t))
  `(add-hook! ,hooks :remove ,@rest))


(defmacro setq-hook! (hooks &rest var-vals)
  "Sets buffer-local variables on HOOKS.

\(fn HOOKS &rest [SYM VAL]...)"
  (declare (indent 1))
  (macroexp-progn
   (cl-loop for (var val hook fn) in (setq-hook-fns hooks var-vals)
            collect `(defun ,fn (&rest _)
                       ,(format "%s = %s" var (pp-to-string val))
                       (setq-local ,var ,val))
            collect `(remove-hook ',hook #',fn) ; ensure set order
            collect `(add-hook ',hook #',fn))))

(defmacro unsetq-hook! (hooks &rest vars)
  "Unbind setq hooks on HOOKS for VARS.

\(fn HOOKS &rest [SYM VAL]...)"
  (declare (indent 1))
  (macroexp-progn
   (cl-loop for (_var _val hook fn)
            in (setq-hook-fns hooks vars 'singles)
            collect `(remove-hook ',hook #',fn))))
#+END_SRC
*** Advice
#+BEGIN_SRC elisp
(defmacro defadvice! (symbol arglist &optional docstring &rest body)
  "Define an advice called SYMBOL and add it to PLACES.

ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'.

\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
  (declare (doc-string 3) (indent defun))
  (unless (stringp docstring)
    (push docstring body)
    (setq docstring nil))
  (let (where-alist)
    (while (keywordp (car body))
      (push `(cons ,(pop body) (enlist ,(pop body)))
            where-alist))
    `(progn
       (defun ,symbol ,arglist ,docstring ,@body)
       (dolist (targets (list ,@(nreverse where-alist)))
         (dolist (target (cdr targets))
           (advice-add target (car targets) #',symbol))))))

(defmacro undefadvice! (symbol _arglist &optional docstring &rest body)
  "Undefine an advice called SYMBOL.

This has the same signature as `defadvice!' an exists as an easy undefiner when
testing advice (when combined with `rotate-text').

\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
  (declare (doc-string 3) (indent defun))
  (let (where-alist)
    (unless (stringp docstring)
      (push docstring body))
    (while (keywordp (car body))
      (push `(cons ,(pop body) (enlist ,(pop body)))
            where-alist))
    `(dolist (targets (list ,@(nreverse where-alist)))
       (dolist (target (cdr targets))
         (advice-remove target #',symbol)))))
#+END_SRC
*** Setter
#+begin_src elisp
(defmacro prependq! (sym &rest lists)
  "Prepend LISTS to SYM in place.

From doom-emacs."
  `(setq ,sym (append ,@lists ,sym)))
#+end_src
*** with-* macros
#+begin_src elisp
(defmacro with-directory (directory &rest body)
  `(let ((default-directory ,directory))
    ,@body))

(defmacro with-contents (contents &rest body)
  `(with-temp-buffer
     (insert ,contents)
     ,@body))
#+end_src
*** String manip
#+begin_src elisp
(defun trim-trailing-newline (string)
  (with-contents string
                 (goto-char (point-max))
                 (when (= (char-before) ?\n)
                   (delete-char -1))
                 (buffer-string)))
#+end_src
*** Debug 
#+begin_src elisp
(defmacro debug-sexps (&rest sexps)
  "Prints SEXPS evaled and their results."
  `(dolist (sexp ',sexps)
    (message "%s => %s"
             (s-trim (pp-to-string sexp))
             (eval sexp))))
#+end_src

** Commands
:PROPERTIES:
:header-args:elisp: :tangle commands-lib.el
:END:
#+begin_src elisp
(provide 'commands-lib)
#+END_SRC

Convenience macro for running a list of commands
#+begin_src elisp
(defmacro run-commands (result-fn &rest commands)
    `(with-temp-buffer
      (let ((after-change-functions after-change-functions))
        (add-to-list 'after-change-functions
                     #'(lambda (start end _)
                         (funcall ,result-fn (buffer-substring start
                                                    ;; chop off trailing newline
                                                    (1- end)))))
        (dolist (command ',commands)
                (shell-command command (current-buffer))))))
#+END_SRC

Wrap around my =d= script for running things as a daemon
#+begin_src elisp
(defun d (command)
  (shell-command (concat "d " command)))
#+END_SRC

Not sure this is the /best/ place for this, but it lives here for now
#+begin_src elisp
(defun firefox (url &optional container)
  (let ((url (if container
                 (format "ext+container:name=%s&url=%s"
                         container
                         (url-hexify-string url))
                 url)))
    (when url
      (d (format "firefox '%s'" url)))))
#+end_src
** Site start
:PROPERTIES:
:header-args:elisp: :tangle site-start.el
:END:
#+BEGIN_SRC elisp
(provide 'site-start)
(require 'global-packages)
(require 'global-settings)
(require 'config-ui)
(require 'personal-lib)
(require 'keymap)
(defadvice! fuck-errors (fn &rest args)
  "Fuck errors. Be quiet."
  :around '(pdf-info-check-epdfinfo)
  (ignore-errors (apply fn args)))
#+END_SRC
** Config
:PROPERTIES:
:header-args:elisp: :tangle config-main.el
:END:
Config packages (those prefixed with =config-=) should not 'do' anything by default.
They should simply provide /my/ configuration preferences for packages, so I can pull
them in anywhere. I may add methods to select which packages to use (and how they are
loaded). I am wanting to avoid loading any packages unless I actually decide I want them.

This might end up following the 'feature' / 'module' pattern that =doom-emacs= does, but
for now it's not so complex.
#+BEGIN_SRC elisp
(provide 'config-main)

(require! config-evil
          config-auth
          config-buffer
          config-email
          config-projects
          config-ui
          config-elisp
          config-ui-themes
          config-org
          config-org-ui
          config-org-babel
          config-org-latex
          config-org-export
          config-selection-completion
          config-introspection
          config-editting
          config-pdf
          config-remote
          config-file-management
          config-window
          config-tab
          config-searching
          config-notes
          config-processes
          config-programming)
#+END_SRC
* Personal
:PROPERTIES:
:header-args+: :dir ${HOME}/.local/emacs/configs/personal
:END:

#+begin_src elisp :tangle init.el
(elpm-use-packages '(ob-async
                     gruvbox-theme
                     vertico
                     dap-mode
                     (evil-org-mode :host github
                                    :repo "Somelauw/evil-org-mode")
                     evil-surround
                     lsp-mode

                     ;; pdf-tools
                     ;; org-pdftools
                     php-mode
                     web-mode
                     rustic
                     racer
                     typescript-mode)
                   user-emacs-directory
                   t)


(require! config-main
          auth-source-pass
          gruvbox
          try

          embark
          evil
          evil-collection
          evil-surround
          eros
          magit
          orderless
          marginalia
          yasnippet
          corfu
          vertico
          which-key
          helpful

          consult

          ;; pdf-tools
          ;; org-pdftools
          php-mode
          web-mode
          rustic

          typescript-mode)

(load "~/.local.el" t)
#+end_src
